#ifndef TORC_AUTODIFF_FN_H
#define TORC_AUTODIFF_FN_H

#include <vector>
#include <fstream>
#include <stdexcept>
#include <iostream>
#include <filesystem>
#include <ctime>
#include "pinocchio/codegen/cppadcg.hpp" // Note that using the pinocchio header is critical!

#include "explicit_fn.h"

namespace torc::fn {
    namespace ADCG = CppAD::cg;
    namespace AD = CppAD;
    namespace fs = std::filesystem;

    /**
     * @brief Class implementation of an arbitrary function, with auto-differentiation functionalities.
     * @tparam scalar_t the type of scalar used for the function
     */
    template <class scalar_t>
    class AutodiffFn: public ExplicitFn<scalar_t> {
        using vectorx_t = Eigen::VectorX<scalar_t>;
        using matrixx_t = Eigen::MatrixX<scalar_t>;
        using cg_t = ADCG::CG<scalar_t>;
        using adcg_t = CppAD::AD<cg_t>;

    public:
        /**s
         * @brief Overloaded constructor for the AutodiffFn class.
         * @param cg_fn the function (must take in a vector of CppAD::cg::CG as input)
         * @param dim the input dimension
         * @param force_generate whether or not to generate even when a library of the same name is found
         * @param timestamp_files whether or not to timestamp the dynamic libraries
         * @param identifier string identifier for the cg_fn
         */
        explicit AutodiffFn(const std::function<adcg_t(const Eigen::VectorX<adcg_t>&)>& cg_fn,
                            const size_t dim=1,
                            const bool& force_generate=false,
                            const bool& timestamp_files=false,
                            const std::string& identifier="AutodiffFnInstance"){
            this->SetName(identifier);
            std::string lib_file_no_ext = FileSetup_(timestamp_files);
            std::string lib_file_path = lib_file_no_ext + LIB_EXT_;
            this->dim_ = dim;

            bool create_lib = true;
            if ((fs::exists(lib_file_path)) && (!force_generate)) {
                size_t loaded_dim = LoadADCGLib_(lib_file_path, this->name_);
                create_lib = (loaded_dim != dim);
            }
            if (create_lib) {
                std::cout << "Compiling derivative..." << std::endl;
                this->dim_ = dim;
                // record operations in the ADFun object
                std::vector<adcg_t> x(dim);
                CppAD::Independent(x);
                Eigen::VectorX<adcg_t> eigen_x = Eigen::Map<Eigen::VectorX<adcg_t> , Eigen::Unaligned>(x.data(), x.size());
                std::vector<adcg_t> y = {cg_fn(eigen_x)};
                AD::ADFun<cg_t> ad_fn(x, y);

                // generate library source code
                ADCG::ModelCSourceGen<double> c_gen(ad_fn, this->name_);
                c_gen.setCreateJacobian(true);
                c_gen.setCreateHessian(true);
                ADCG::ModelLibraryCSourceGen<double> lib_gen(c_gen);
                ADCG::DynamicModelLibraryProcessor<double> lib_processor(lib_gen, lib_file_no_ext);

                // compile source code into a dynamic library
                ADCG::GccCompiler<double> compiler;
                this->cg_lib_ = lib_processor.createDynamicLibrary(compiler);
                this->cg_model_ = this->cg_lib_->model(this->name_);
            }
            LoadFunction(cg_fn, dim);
            LoadDifferentials();
        }

        /**
         * @brief Overloaded constructor for the AutodiffFn class which loads a dynamic library generated by CppAD CodeGen.
         * @param cg_fn the original function (not serialized by codegen)
         * @param path the path to the dynamic library, can be relative or absolute
         * @param identifier string identifier, must match the identifier name that was used for the library
         */
        AutodiffFn(const std::function<adcg_t(Eigen::VectorX<adcg_t>)>& cg_fn,
                   const std::string& path,
                   const std::string& identifier="AutodiffFnInstance") {
            if (!fs::exists(path)) {
                throw std::runtime_error("Specified path does not exist.");
            }
            this->SetName(identifier);
            this->dim_ = LoadADCGLib_(path, this->name_);
            LoadFunction(cg_fn, this->dim_);
            LoadDifferentials();
        }

    private:
        std::unique_ptr<ADCG::DynamicLib<double>> cg_lib_; // we must hold a pointer to the dynamic library
        std::unique_ptr<ADCG::GenericModel<double>> cg_model_; // stores the operation tape and differential information
        const std::string ADCG_SOURCE_DIR_ = "adcg_sources";
        const std::string LIB_EXT_ = ".so";

        /**
         * @brief Sets up the directory structure. Creates a directory ./ADCG_SOURCE_DIR, and scans the directory for previously
         * created dynamic libraries to determine what the current one's path should be. The library files are named
         * identifier-time(y-m-d-h-m-s).so
         * @param timestamp Whether or not to timestamp the file. If false, then the file will be named identifier.so
         * @return the full file path without the extension
         */
        std::string FileSetup_(const bool &timestamp) {
            std::string time_str;
            if (timestamp) {
                const int TIM_PATH_LEN = 80;
                time_t raw_time;
                time (&raw_time);
                char buffer[TIM_PATH_LEN];
                strftime(buffer,sizeof(buffer),"%Y-%m-%d-%H-%M-%S", localtime(&raw_time));
                time_str = buffer;
            }
            fs::path lib_dir_path = fs::current_path() / ADCG_SOURCE_DIR_;
            std::string lib_name = this->name_ + time_str;
            fs::create_directories(lib_dir_path);
            return lib_dir_path / lib_name;
        }

        /**
         * @brief Loads an Autodiff CodeGen dynamic library into the AutodiffFn object. Updates the cg_model_, cg_lib_,
         * and dim_ attributes of the class.
         * @param path the path to the dynamic library
         * @return the domain dimension of the loaded library
         */
        size_t LoadADCGLib_(const std::string &path, const std::string& name) {
            ADCG::LinuxDynamicLib<double> dlib(path);
            this->cg_lib_ = std::unique_ptr<ADCG::DynamicLib<scalar_t>>(new ADCG::LinuxDynamicLib<double>(std::move(dlib)));
            this->cg_model_ = cg_lib_->model(name);
            return this->cg_model_->Domain();
        }

        /**
         * @brief Loads a ADCG function into the func_ attribute of the class, which operates on scalar_t
         * @param cg_fn the ADCG function
         */
        void LoadFunction(const std::function<adcg_t(Eigen::VectorX<adcg_t>)>& cg_fn, const size_t& dim) {
            // original function
            const std::function<scalar_t(vectorx_t)> func = [cg_fn, dim](const vectorx_t& x) {
                Eigen::VectorX<adcg_t> x_eigen(dim);
                for (size_t i = 0; i < dim; ++i) {
                    x_eigen[i] = adcg_t(x[i]);
                }
                return AD::Value(cg_fn(x_eigen)).getValue();    // first get the cg_t, then extract the scalar_t
            };
            this->func_ = func;
        }

        /**
         * @brief Loads differential functions (gradient and Hessian) into the respective attributes of the class from the
         * dynamic library model. Assumes the dimension of the class is correct.
         */
        void LoadDifferentials() {
            // gradient
            this->grad_ = [this](const vectorx_t& x) {
                const std::vector<scalar_t> x_std(x.data(), x.data() + x.size());
                std::vector<scalar_t> jac = this->cg_model_->Jacobian(x_std);
                vectorx_t grad = Eigen::Map<vectorx_t , Eigen::Unaligned>(jac.data(), jac.size());
                return grad;
            };

            // Hessian
            this->hess_ = [this](const vectorx_t& x) {
                const std::vector<scalar_t> x_std(x.data(), x.data()+x.size());
                const size_t dim  = this->dim_;
                std::vector<scalar_t> hess = this->cg_model_->Hessian(x_std, 0);
                matrixx_t grad_eigen(dim, dim);
                for (size_t n_row=0; n_row < dim; n_row++) {
                    Eigen::RowVectorX<scalar_t> grad_row_eigen = Eigen::Map<Eigen::RowVectorX<scalar_t>, Eigen::Unaligned>(hess.data() + n_row * dim, (n_row + 1) * dim);
                    grad_row_eigen.conservativeResize(dim);  // so row assignment doesn't complain
                    grad_eigen.row(n_row) << grad_row_eigen;
                }
                return grad_eigen;
            };
        }
    };
} // namespace torc::fn

#endif //TORC_AUTODIFF_FN_H