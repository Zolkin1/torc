#ifndef TORC_AUTODIFF_FN_H
#define TORC_AUTODIFF_FN_H

#include <vector>
#include <iostream>
#include <fstream>
#include <stdexcept>
#include <filesystem>
#include <ctime>
#include <cppad/cg.hpp>
#include "base_fn.h"

namespace torc::fn {
    namespace ADCG = CppAD::cg;
    namespace AD = CppAD;
    namespace fs = std::filesystem;

    /**
     * Class implementation of an arbitrary function, with auto-differentiation functionalities.
     * @tparam scalar_t the type of scalar used for the function
     */
    template <class scalar_t>
    class AutodiffFn: public BaseFn<scalar_t> {
        using vectorx_t = Eigen::VectorX<scalar_t>;
        using matrixx_t = Eigen::MatrixX<scalar_t>;
        using cg_t = ADCG::CG<scalar_t>;
        using adcg_t = CppAD::AD<cg_t>;

    public:
        /**
         * Overloaded constructor for the AutodiffFn class.
         * @param fn the fn function
         * @param dim the input dimension
         * @param force_generate whether or not to generate even when a library of the same name is found
         * @param timestamp_files whether or not to timestamp the dynamic libraries
         * @param identifier string identifier for the fn
         */
        explicit AutodiffFn(const std::function<adcg_t(Eigen::VectorX<adcg_t>)>& fn,
                            const size_t dim,
                            const bool& force_generate=false,
                            const bool& timestamp_files=false,
                            const std::string& identifier="AutodiffFnInstance") {
            this->fn_ = fn;
            // the library has some issue with the identifier if it contains spaces/special characters. We impose a
            // stricter requirement on the identifier; strings like "-auto" will also work.
            this->SetIdentifier(identifier);
            std::string lib_file_no_ext = FileSetup_(timestamp_files);
            std::string lib_file_path = lib_file_no_ext + LIB_EXT_;
            bool create_lib = true;
            if ((fs::exists(lib_file_path)) && (!force_generate)) {
                LoadADCGModelLib_(lib_file_path);
                create_lib = (this->dim_ != dim);
            }
            if (create_lib) {
                // record operations in the ADFun object
                std::vector<adcg_t> x(dim);
                CppAD::Independent(x);
                Eigen::VectorX<adcg_t> eigen_x = Eigen::Map<Eigen::VectorX<adcg_t> , Eigen::Unaligned>(x.data(), x.size());
                std::vector<adcg_t> y = {fn(eigen_x)};
                AD::ADFun<cg_t> ad_fn(x, y);

                // generate library source code
                ADCG::ModelCSourceGen<double> c_gen(ad_fn, this->identifier_);
                c_gen.setCreateJacobian(true);
                c_gen.setCreateHessian(true);
                ADCG::ModelLibraryCSourceGen<double> lib_gen(c_gen);
                ADCG::DynamicModelLibraryProcessor<double> libprocessor(lib_gen, lib_file_no_ext);

                // compile source code into a dynamic library
                ADCG::GccCompiler<double> compiler;
                this->cg_dynamic_lib_ = libprocessor.createDynamicLibrary(compiler);
                this->cg_model_ = cg_dynamic_lib_->model(this->identifier_);
                this->dim_ = dim;
            }
        }

        /**
         * Overloaded constructor for the AutodiffFn class which loads a dynamic library generated by CppAD CodeGen.
         * @param fn the original function (not serialized by codegen)
         * @param path the path to the dynamic library
         * @param identifier string identifier, must match the identifier name that was used for the library
         */
        AutodiffFn(const std::function<adcg_t(Eigen::VectorX<adcg_t>)>& fn,
                   const std::string& path,
                   const std::string& identifier="AutodiffFnInstance") {
            if (!fs::exists(path)) {
                throw std::runtime_error("Specified path does not exist.");
            }
            this->fn_ = fn;
            this->SetIdentifier(identifier);
            LoadADCGModelLib_(path);
        }

        /**
         * Evaluates the function at a given point
         * @param x the input to the function
         * @return f(x)
         */
        scalar_t Evaluate(const vectorx_t& x) const {
            Eigen::VectorX<adcg_t> x_eigen(this->dim_);
            for (int i = 0; i < this->dim_; ++i) {
                x_eigen[i] = adcg_t(x[i]);
            }
            return AD::Value(this->fn_(x_eigen)).getValue();    // first get the cg_t, then extract the scalar_t
        }

        /**
         * Evaluates the gradient of the fn evaluated at x
         * @param x the input
         * @return grad f(x)
         */
        vectorx_t Gradient(const vectorx_t& x) const {
            const std::vector<scalar_t> x_std(x.data(), x.data() + x.size());
            if (cg_model_->isJacobianAvailable()) {
                std::vector<scalar_t> jac = cg_model_->Jacobian(x_std);
                return Eigen::Map<vectorx_t , Eigen::Unaligned>(jac.data(), jac.size());
            } else {
                throw std::runtime_error("Jacobian not available.");
            }
        }

        /**
         * Evaluates the Hessian of the fn evaluated at x
         * @param x the input
         * @return H_f(x)
         */
        matrixx_t Hessian(const vectorx_t& x) const {
            const std::vector<scalar_t> x_std(x.data(), x.data()+x.size());
            const int dim = this->dim_;
            if (cg_model_->isHessianAvailable()) {
                std::vector<scalar_t> hess = cg_model_->Hessian(x_std, 0);
                matrixx_t grad_eigen(dim, dim);
                for (size_t nrow=0; nrow < dim; nrow++) {
                    Eigen::RowVectorX<scalar_t> grad_row_eigen = Eigen::Map<Eigen::RowVectorX<scalar_t> , Eigen::Unaligned>(hess.data() + nrow * dim, (nrow + 1) * dim);
                    grad_row_eigen.conservativeResize(this->dim_);  // so nrow assignment doesn't complain
                    grad_eigen.row(nrow) << grad_row_eigen;
                }
                return grad_eigen;
            } else {
                throw std::runtime_error("Hessian not available.");
            }
        }

    private:
        std::function<adcg_t(Eigen::VectorX<adcg_t>)> fn_;          // the original function
        std::unique_ptr<ADCG::DynamicLib<double>> cg_dynamic_lib_;  // stores the operation tape and differential information
        std::unique_ptr<ADCG::GenericModel<double>> cg_model_;
        const std::string ADCG_SOURCE_DIR_ = "adcg_sources";
        const std::string LIB_EXT_ = ".so";

        /**
         * Sets up the directory structure. Creates a directory ./ADCG_SOURCE_DIR, and scans the directory for previously
         * created dynamic libraries to determine what the current one's path should be. The library files are named
         * identifier-time(y-m-d-h-m-s).so
         * @param timestamp Whether or not to timestamp the file. If false, then the file will be named identifier.so
         * @return the full file path without the extension
         */
        std::string FileSetup_(const bool &timestamp) {
            std::string time_str;
            if (timestamp) {
                const int TIM_PATH_LEN = 80;
                time_t raw_time;
                time (&raw_time);
                char buffer[TIM_PATH_LEN];
                strftime(buffer,sizeof(buffer),"%Y-%m-%d-%H-%M-%S", localtime(&raw_time));
                time_str = buffer;
            }
            fs::path lib_dir_path = fs::current_path() / ADCG_SOURCE_DIR_;
            std::string lib_name = this->identifier_ + time_str;
            fs::create_directories(lib_dir_path);
            return lib_dir_path / lib_name;
        }

        /**
         * Loads an Autodiff CodeGen dynamic library into the AutodiffFn object. Updates the cg_model_, cg_dynamic_lib_,
         * and dim_ attributes of the class.
         * @param path the absolute file path to the dynamic library
         */
        void LoadADCGModelLib_(const std::string &path) {
            ADCG::LinuxDynamicLib<double> dlib(path);
            this->cg_dynamic_lib_ = std::unique_ptr<ADCG::DynamicLib<scalar_t>>(new ADCG::LinuxDynamicLib<double>(std::move(dlib)));
            this->cg_model_ = cg_dynamic_lib_->model(this->identifier_);
            this->dim_ = this->cg_model_->Domain();
        }
    };
} // namespace torc::fn

#endif //TORC_AUTODIFF_FN_H